{"ast":null,"code":"import { dutchTrainStations } from '../data/trainStations';\n\n// Mock data for demonstration - in a real app, this would come from APIs\nconst mockResults = [{\n  id: '1',\n  name: 'Albert Heijn',\n  type: 'Supermarket',\n  address: 'Stationsplein 1',\n  lat: 52.3801,\n  lng: 4.9013,\n  rating: 4.2\n}, {\n  id: '2',\n  name: 'McDonald\\'s',\n  type: 'Restaurant',\n  address: 'Stationsplein 5',\n  lat: 52.3785,\n  lng: 4.8995,\n  rating: 3.8,\n  openingHours: '24/7'\n}, {\n  id: '3',\n  name: 'Fitness First',\n  type: 'Gym',\n  address: 'Damrak 10',\n  lat: 52.3761,\n  lng: 4.8950,\n  rating: 4.5\n}, {\n  id: '4',\n  name: 'Pathé Cinema',\n  type: 'Cinema',\n  address: 'Nieuwezijds Voorburgwal 120',\n  lat: 52.3720,\n  lng: 4.8920,\n  rating: 4.3\n}];\n\n// Calculate distance between two coordinates using Haversine formula\nfunction calculateDistance(lat1, lng1, lat2, lng2) {\n  const R = 6371; // Earth's radius in kilometers\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLng = (lng2 - lng1) * Math.PI / 180;\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\nexport async function searchLocations(filters) {\n  // Find the selected train station\n  const station = dutchTrainStations.find(s => s.id === filters.stationId);\n  if (!station) return [];\n\n  // In a real implementation, you would call external APIs here:\n  // - Overpass API for OpenStreetMap data\n  // - Google Places API\n  // - Foursquare API\n  // - Local business directories\n\n  // For demo purposes, generate results around the station\n  const results = [];\n  for (const mockResult of mockResults) {\n    // Add some randomness to position results around the station\n    const randomLat = station.lat + (Math.random() - 0.5) * 0.01;\n    const randomLng = station.lng + (Math.random() - 0.5) * 0.01;\n    const distance = calculateDistance(station.lat, station.lng, randomLat, randomLng);\n\n    // Only include results within the specified distance\n    if (distance <= filters.distance) {\n      // Filter by category if specified\n      if (filters.category === '' || filters.category === 'all' || mockResult.type.toLowerCase().includes(filters.category.toLowerCase())) {\n        // Filter by search query if specified\n        if (filters.query === '' || mockResult.name.toLowerCase().includes(filters.query.toLowerCase()) || mockResult.type.toLowerCase().includes(filters.query.toLowerCase())) {\n          results.push({\n            ...mockResult,\n            lat: randomLat,\n            lng: randomLng,\n            distance: Math.round(distance * 100) / 100,\n            trainStation: station\n          });\n        }\n      }\n    }\n  }\n\n  // Sort by distance\n  return results.sort((a, b) => a.distance - b.distance);\n}\nexport function getTrainStations() {\n  return dutchTrainStations;\n}","map":{"version":3,"names":["dutchTrainStations","mockResults","id","name","type","address","lat","lng","rating","openingHours","calculateDistance","lat1","lng1","lat2","lng2","R","dLat","Math","PI","dLng","a","sin","cos","c","atan2","sqrt","searchLocations","filters","station","find","s","stationId","results","mockResult","randomLat","random","randomLng","distance","category","toLowerCase","includes","query","push","round","trainStation","sort","b","getTrainStations"],"sources":["/workspace/src/services/api.ts"],"sourcesContent":["import { SearchResult, SearchFilters, TrainStation } from '../types';\nimport { dutchTrainStations } from '../data/trainStations';\n\n// Mock data for demonstration - in a real app, this would come from APIs\nconst mockResults: Omit<SearchResult, 'trainStation' | 'distance'>[] = [\n  {\n    id: '1',\n    name: 'Albert Heijn',\n    type: 'Supermarket',\n    address: 'Stationsplein 1',\n    lat: 52.3801,\n    lng: 4.9013,\n    rating: 4.2\n  },\n  {\n    id: '2',\n    name: 'McDonald\\'s',\n    type: 'Restaurant',\n    address: 'Stationsplein 5',\n    lat: 52.3785,\n    lng: 4.8995,\n    rating: 3.8,\n    openingHours: '24/7'\n  },\n  {\n    id: '3',\n    name: 'Fitness First',\n    type: 'Gym',\n    address: 'Damrak 10',\n    lat: 52.3761,\n    lng: 4.8950,\n    rating: 4.5\n  },\n  {\n    id: '4',\n    name: 'Pathé Cinema',\n    type: 'Cinema',\n    address: 'Nieuwezijds Voorburgwal 120',\n    lat: 52.3720,\n    lng: 4.8920,\n    rating: 4.3\n  }\n];\n\n// Calculate distance between two coordinates using Haversine formula\nfunction calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n  const R = 6371; // Earth's radius in kilometers\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLng = (lng2 - lng1) * Math.PI / 180;\n  const a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * \n    Math.sin(dLng/2) * Math.sin(dLng/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n}\n\nexport async function searchLocations(filters: SearchFilters): Promise<SearchResult[]> {\n  // Find the selected train station\n  const station = dutchTrainStations.find(s => s.id === filters.stationId);\n  if (!station) return [];\n\n  // In a real implementation, you would call external APIs here:\n  // - Overpass API for OpenStreetMap data\n  // - Google Places API\n  // - Foursquare API\n  // - Local business directories\n\n  // For demo purposes, generate results around the station\n  const results: SearchResult[] = [];\n  \n  for (const mockResult of mockResults) {\n    // Add some randomness to position results around the station\n    const randomLat = station.lat + (Math.random() - 0.5) * 0.01;\n    const randomLng = station.lng + (Math.random() - 0.5) * 0.01;\n    \n    const distance = calculateDistance(station.lat, station.lng, randomLat, randomLng);\n    \n    // Only include results within the specified distance\n    if (distance <= filters.distance) {\n      // Filter by category if specified\n      if (filters.category === '' || \n          filters.category === 'all' || \n          mockResult.type.toLowerCase().includes(filters.category.toLowerCase())) {\n        \n        // Filter by search query if specified\n        if (filters.query === '' || \n            mockResult.name.toLowerCase().includes(filters.query.toLowerCase()) ||\n            mockResult.type.toLowerCase().includes(filters.query.toLowerCase())) {\n          \n          results.push({\n            ...mockResult,\n            lat: randomLat,\n            lng: randomLng,\n            distance: Math.round(distance * 100) / 100,\n            trainStation: station\n          });\n        }\n      }\n    }\n  }\n\n  // Sort by distance\n  return results.sort((a, b) => a.distance - b.distance);\n}\n\nexport function getTrainStations(): TrainStation[] {\n  return dutchTrainStations;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}